#!/usr/bin/env python
#pylint: disable=invalid-name

import argparse
import math
from deterministic import node_from_str, PrivBIP32Node
from mnemonic import Mnemonic

def range_from_str(s):
    'return a arange from a string in x-y format'
    return range(*map(int, s.split('-'))) if '-' in s else range(int(s))

parser = argparse.ArgumentParser(description='Key Utility')
parser.add_argument('-p', '--path', help='derivation path')
parser.add_argument('-w', '--wif',
                    help='print leaf private keys (compressed WIF format)',
                    action='store_true')
parser.add_argument('-l', default=range(25),
                    type=range_from_str, help='''Range of leaf indices to
                    compute. Format is x-y. If only one number is given x is
                    assumed to be zero.''')
parser.add_argument('keydata', nargs='?', default=None,
                    help=''' Key specification. This can be a BIP32 standard
                    xpub or xprv key string, a space delimited string of
                    mnemonic words, a hex encoded BIP32 seed, a number of bytes
                    to use as entropy for generating a random mnemonic, or
                    blank which defaults to 20 bytes of entropy for generating
                    a random mnemonic''')
parser.add_argument('-n', '--network', help='network name', default='BTC',
                    choices=['BTC', 'LTC'])
args = parser.parse_args()

addrpre = {'BTC' : b'\0', 'LTC' : b'0'}
wifpre = {'BTC' : b'\x80', 'LTC' : b'\xb0'}

print('Root key info ' + '-' * 97)

if args.keydata is None:
    m = Mnemonic()
elif args.keydata.isdigit() and len(args.keydata) < 4:
    m = Mnemonic(int(args.keydata))
elif ' ' in args.keydata:
    m = Mnemonic.from_string(args.keydata)
elif args.keydata.startswith('xp'):
    r = node_from_str(args.keydata)
elif set(args.keydata) <= set('1234567890abcdefABCDEF'):
    seed = bytes.fromhex(args.keydata)

if 'm' in locals():
    assert m.check(), 'Not a valid Mnemonnic'
    print('Mnemonic : %s' % str(m))
    seed = m.to_seed()

if 'seed' in locals():
    if len(seed) < 56:
        print('seed     : %s' % seed.hex())
    else:
        print('seed     : %s...%s' % (seed.hex()[:30], seed.hex()[-30:]))
    r = PrivBIP32Node.from_entropy(seed)

print(r)

if args.path:
    mend = r.derive(args.path) if args.path else r
    print('')
    print('Derived Key info ' + '-' * 94)
    print('path     : %s' % args.path)
    print(mend)
else:
    mend = r

print('')
print('Leaves ' + '-' * 104)
if not args.wif and isinstance(mend, PrivBIP32Node):
    mend = mend.to_pub()
for i in args.l:
    xkey = mend.ckd(i)
    addr = xkey.addr(addrpre[args.network])
    keydat = xkey.wif(wifpre[args.network]) if args.wif else bytes(xkey.K).hex()
    ll = math.ceil(math.log10(args.l.stop))
    print(('%' + str(ll) + 'd %-34s %s') % (i, addr, keydat))
